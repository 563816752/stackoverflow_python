{"./":{"url":"./","title":"Introduction","keywords":"","body":" 打发无聊时间翻译的Stack Overflow关于Python的部分,一来是为了学习Python,二来是为了学习英语,就这样. PS:按vote排名翻译 待翻译 13 http://effbot.org/zone/default-values.htm 20 http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python 35 http://stackoverflow.com/questions/3684484/peak-detection-in-a-2d-array 64 http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python 部分6 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-03-30 19:35:35 "},"part1/1.html":{"url":"part1/1.html","title":"Python中关键字yield有什么作用?","keywords":"","body":"Python中关键字yield有什么作用? rank ▲ ✰ vote url 1 2888 2315 4033 url Python中关键字yield有什么作用? yield有什么用? 例如下面这段代码: def node._get_child_candidates(self, distance, min_dist, max_dist): if self._leftchild and distance - max_dist = self._median: yield self._rightchild 下面是调用它: result, candidates = list(), [self] while candidates: node = candidates.pop() distance = node._get_dist(obj) if distance = min_dist: result.extend(node._values) candidates.extend(node._get_child_candidates(distance, min_dist, max_dist)) return result 当_get_child_candidates方法被调用的时候发生了什么?是返回一个列表?还是一个元祖?它还能第二次调用吗?后面的调用什么时候结束? 为了理解yield有什么用,首先得理解generators,而理解generators前还要理解iterables Iterables 当你创建了一个列表,你可以一个一个的读取它的每一项,这叫做iteration: >>> mylist = [1, 2, 3] >>> for i in mylist: ... print(i) 1 2 3 Mylist是可迭代的.当你用列表推导式的时候,你就创建了一个列表,而这个列表也是可迭代的: >>> mylist = [x*x for x in range(3)] >>> for i in mylist: ... print(i) 0 1 4 所有你可以用在for...in...语句中的都是可迭代的:比如lists,strings,files...因为这些可迭代的对象你可以随意的读取所以非常方便易用,但是你必须把它们的值放到内存里,当它们有很多值时就会消耗太多的内存. Generators 生成器也是迭代器的一种,但是你只能迭代它们一次.原因很简单,因为它们不是全部存在内存里,它们只在要调用的时候在内存里生成: >>> mygenerator = (x*x for x in range(3)) >>> for i in mygenerator: ... print(i) 0 1 4 生成器和迭代器的区别就是用()代替[],还有你不能用for i in mygenerator第二次调用生成器:首先计算0,然后会在内存里丢掉0去计算1,直到计算完4. Yield Yield的用法和关键字return差不多,下面的函数将会返回一个生成器: >>> def createGenerator(): ... mylist = range(3) ... for i in mylist: ... yield i*i ... >>> mygenerator = createGenerator() # 创建生成器 >>> print(mygenerator) # mygenerator is an object! >>> for i in mygenerator: ... print(i) 0 1 4 在这里这个例子好像没什么用,不过当你的函数要返回一个非常大的集合并且你希望只读一次的话,那么它就非常的方便了. 要理解Yield你必须先理解当你调用函数的时候,函数里的代码并没有运行.函数仅仅返回生成器对象,这就是它最微妙的地方:-) 然后呢,每当for语句迭代生成器的时候你的代码才会运转. 现在,到了最难的部分: 当for语句第一次调用函数里返回的生成器对象,函数里的代码就开始运作,直到碰到yield,然后会返回本次循环的第一个返回值.所以下一次调用也将运行一次循环然后返回下一个值,直到没有值可以返回. 一旦函数运行并且没有碰到yeild语句就认为生成器已经为空了.原因有可能是循环结束或者没有满足if/else之类的. 对于你的代码的解释 生成器: # 这里你创建node方法的对象将会返回一个生成器 def node._get_child_candidates(self, distance, min_dist, max_dist): # 这里的代码你每次使用生成器对象的时候将会调用 if self._leftchild and distance - max_dist = self._median: yield self._rightchild # 如果代码运行到这里,生成器就被认为变成了空的 调用: # 创建空列表和一个当前对象索引的列表 result, candidates = list(), [self] # 在candidates上进行循环(在开始只保含一个元素) while candidates: # 获得最后一个condidate然后从列表里删除 node = candidates.pop() # 获取obj和candidate的distance distance = node._get_dist(obj) # 如果distance何时将会填入result if distance = min_dist: result.extend(node._values) candidates.extend(node._get_child_candidates(distance, min_dist, max_dist)) return result 这段代码有几个有意思的地方: 一般的时候我们会在循环迭代一个列表的同时在列表中添加元素:-)尽管在有限循环里结束多少有一些危险,但也不失为一个简单的方法去遍历嵌套的数据.在这里candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))将遍历生成器的每一个值,但是while循环中的condidates将不再保存已经遍历过的生成器对象，也就是说添加进condidates的生成器对象只会遍历一遍。 extend()是一个列表对象的方法,它可以把一个迭代对象添加进列表. 我们经常这么用: >>> a = [1, 2] >>> b = [3, 4] >>> a.extend(b) >>> print(a) [1, 2, 3, 4] 但是在你给的代码里得到的是生成器,这样做的好处: 你不需要读这个值两次 你能得到许多孩子节点但是你不希望他们全部存入内存. 这种方法之所以能很好的运行是因为Python不关心方法的参数是不是一个列表.它只希望接受一个迭代器,所以不管是strings,lists,tuples或者generators都可以!这种方法叫做duck typing,这也是Python看起来特别cool的原因之一.但是这又是另外一个传说了,另一个问题 好了,看到这里可以打住了,下面让我们看看生成器的高级用法: 控制迭代器的穷尽 >>> class Bank(): # 让我们建个银行,生产许多ATM ... crisis = False ... def create_atm(self): ... while not self.crisis: ... yield \"$100\" >>> hsbc = Bank() # 当一切就绪了你想要多少ATM就给你多少 >>> corner_street_atm = hsbc.create_atm() >>> print(corner_street_atm.next()) $100 >>> print(corner_street_atm.next()) $100 >>> print([corner_street_atm.next() for cash in range(5)]) ['$100', '$100', '$100', '$100', '$100'] >>> hsbc.crisis = True # cao,经济危机来了没有钱了! >>> print(corner_street_atm.next()) >>> wall_street_atm = hsbc.create_atm() # 对于其他ATM,它还是True >>> print(wall_street_atm.next()) >>> hsbc.crisis = False # 麻烦的是,尽管危机过去了,ATM还是空的 >>> print(corner_street_atm.next()) >>> brand_new_atm = hsbc.create_atm() # 只能重新新建一个bank了 >>> for cash in brand_new_atm: ... print cash $100 $100 $100 $100 $100 $100 $100 $100 $100 ... 它对于一些不断变化的值很有用,比如说用来控制资源的访问. Itertools,你的好基友 itertools模块包含了一些特殊的函数可以操作可迭代对象.有没有想过复制一个生成器?链接两个生成器?把嵌套列表里的值组织成一个列表?Map/Zip还不用创建另一个列表? 来吧import itertools 来一个例子?让我们看看4匹马比赛有多少个排名结果: >>> horses = [1, 2, 3, 4] >>> races = itertools.permutations(horses) >>> print(races) >>> print(list(itertools.permutations(horses))) [(1, 2, 3, 4), (1, 2, 4, 3), (1, 3, 2, 4), (1, 3, 4, 2), (1, 4, 2, 3), (1, 4, 3, 2), (2, 1, 3, 4), (2, 1, 4, 3), (2, 3, 1, 4), (2, 3, 4, 1), (2, 4, 1, 3), (2, 4, 3, 1), (3, 1, 2, 4), (3, 1, 4, 2), (3, 2, 1, 4), (3, 2, 4, 1), (3, 4, 1, 2), (3, 4, 2, 1), (4, 1, 2, 3), (4, 1, 3, 2), (4, 2, 1, 3), (4, 2, 3, 1), (4, 3, 1, 2), (4, 3, 2, 1)] 理解迭代的内部机制 迭代是可迭代对象(对应__iter__()方法)和迭代器(对应__next__()方法)的一个过程.可迭代对象就是任何你可以迭代的对象(废话啊).迭代器就是可以让你迭代可迭代对象的对象(有点绕口,意思就是这个意思) 预知后事如何,请看for 循环是如何工作的 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:53:55 "},"part1/2.html":{"url":"part1/2.html","title":"Python中的元类(metaclass)是什么?","keywords":"","body":"Python中的元类(metaclass)是什么? rank ▲ ✰ vote url 2 1919 1842 3137 url Python中的元类(metaclass)是什么? 元类是什么?如何使用元类? 类对象 在理解元类之前,你需要掌握Python里的类.Python中类的概念借鉴于Smalltalk，这显得有些奇特. 在大多数语言中,类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立： >>> class ObjectCreator(object): ... pass ... >>> my_object = ObjectCreator() >>> print(my_object) 但是在Python中类也是对象. 是的,对象. 每当你用到关键字class, Python就会执行它并且建立一个对象.例如: >>> class ObjectCreator(object): ... pass ... 上面代码在内存里创建了名叫\"ObjectCreator\"的对象. 这个对象(类)有生成对象(实例)的能力,这就是为什么叫做类. 它是个对象,所以: 你可以把它赋值给一个变量 你可以赋值它 你可以给它添加属性 你个以作为函数参数来传递它 e.g.: >>> print(ObjectCreator) # 你可以打印一个类,因为它是一个对象 >>> def echo(o): ... print(o) ... >>> echo(ObjectCreator) # 你可以把类作为参数传递 >>> print(hasattr(ObjectCreator, 'new_attribute')) False >>> ObjectCreator.new_attribute = 'foo' # 可以给一个类添加属性 >>> print(hasattr(ObjectCreator, 'new_attribute')) True >>> print(ObjectCreator.new_attribute) foo >>> ObjectCreatorMirror = ObjectCreator # 可以把类赋值给一个变量 >>> print(ObjectCreatorMirror.new_attribute) foo >>> print(ObjectCreatorMirror()) 动态创建类 因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。 首先，你可以在函数中创建类，使用class关键字即可: >>> def choose_class(name): ... if name == 'foo': ... class Foo(object): ... pass ... return Foo # 返回一个类不是一个实例 ... else: ... class Bar(object): ... pass ... return Bar ... >>> MyClass = choose_class('foo') >>> print(MyClass) # 返回一个类不是一个实例 >>> print(MyClass()) # 你可以在类里创建一个对象 但这还不够动态,因为你仍然需要自己编写整个类的代码. 既然类是对象,那么肯定有什么东西来生成它. 当你使用关键字objects,Python自动的创建对象.像Python中大多数的东西一样,他也给你自己动手的机会. 记得函数type吗?这个古老好用的函数能让你知道对象的类型是什么: >>> print(type(1)) >>> print(type(\"1\")) >>> print(type(ObjectCreator)) >>> print(type(ObjectCreator())) 这里, type 有一种完全不同的能力,它也能动态的创建类. type 可以接受一个类的描述作为参数,然后返回一个类. (我知道，根据传入参数的不同，同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后兼容性) type 这样工作: type(类名, 父类名的元组 (针对继承情况,可以为空), 包含属性的字典(名称和值)) e.g.: >>> class MyShinyClass(object): ... pass 可以手动创建: >>> MyShinyClass = type('MyShinyClass', (), {}) # 返回类对象 >>> print(MyShinyClass) >>> print(MyShinyClass()) # 创建一个类的实例 你会发现我们使用“MyShinyClass”作为类名，并且也可以把它当做一个变量来作为类的引用。类和变量是不同的，这里没有任何理由把事情弄的复杂。 type 可以接受一个字典来定义类的属性: >>> class Foo(object): ... bar = True 可以写成: >>> Foo = type('Foo', (), {'bar':True}) 然后我们可以像用正常类来用它: >>> print(Foo) >>> print(Foo.bar) True >>> f = Foo() >>> print(f) >>> print(f.bar) True 当然,你也可以继承它: >>> class FooChild(Foo): ... pass 这样: >>> FooChild = type('FooChild', (Foo,), {}) >>> print(FooChild) >>> print(FooChild.bar) # bar从Foo继承 True 要是在类中添加方法,你要做的就是把函数名写入字典就可以了,不懂可以看下面: >>> def echo_bar(self): ... print(self.bar) ... >>> FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar}) >>> hasattr(Foo, 'echo_bar') False >>> hasattr(FooChild, 'echo_bar') True >>> my_foo = FooChild() >>> my_foo.echo_bar() True 你可以看到，在Python中，类也是对象，你可以动态的创建类。这就是当你使用关键字class时Python在幕后做的事情，而这就是通过元类来实现的。 什么是元类(终于到正题了) 元类就是创建类的东西. 你是为了创建对象才定义类的,对吧? 但是我们已经知道了Python的类是对象. 这里,元类创建类.它们是类的类,你可以把它们想象成这样: MyClass = MetaClass() MyObject = MyClass() 你已经看到了type可以让你像这样做： MyClass = type('MyClass', (), {}) 这是因为type就是一个元类.type是Python中创建所有类的元类. 现在你可能纳闷为啥子type用小写而不写成Type? 我想是因为要跟str保持一致,str创建字符串对象,int创建整数对象.type正好创建类对象. 你可以通过检查__class__属性来看到这一点. Python中所有的东西都是对象.包括整数,字符串,函数还有类.所有这些都是对象.所有这些也都是从类中创建的: >>> age = 35 >>> age.__class__ >>> name = 'bob' >>> name.__class__ >>> def foo(): pass >>> foo.__class__ >>> class Bar(object): pass >>> b = Bar() >>> b.__class__ 那么,__class__的__class__属性是什么? >>> age.__class__.__class__ >>> name.__class__.__class__ >>> foo.__class__.__class__ >>> b.__class__.__class__ 所以,元类就是创建类对象的东西. 如果你愿意你也可以把它叫做'类工厂'.type是Python的内建元类,当然,你也可以创建你自己的元类. __metaclass__属性 当你创建一个函数的时候,你可以添加__metaclass__属性: class Foo(object): __metaclass__ = something... [...] 如果你这么做了，Python就会用元类来创建类Foo. 小心点，这里面有些技巧. 你首先写下class Foo(object，但是类对象Foo还没有在内存中创建. Python将会在类定义中寻找__metaclass__.如果找打了就用它来创建类对象Foo.如果没找到,就会默认用type创建类. 把下面这段话反复读几次。 当你写如下代码时 : class Foo(Bar): pass Python将会这样运行: 在Foo中有没有___metaclass__属性? 如果有,Python会在内存中通过__metaclass__创建一个名字为Foo的类对象(我说的是类对象,跟紧我的思路). 如果Python没有找到__metaclass__，它会继续在Bar（父类）中寻找__metaclass__属性，并尝试做和前面同样的操作. 如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。 如果还是找不到__metaclass__,Python就会用内置的type来创建这个类对象。 现在的问题就是，你可以在__metaclass__中放置些什么代码呢？ 答案就是：可以创建一个类的东西。 那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东东都可以。 自定义元类 元类的主要目的就是为了当创建类时能够自动地改变类. 通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类. 假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。有好几种方法可以办到，但其中一种就是通过在模块级别设定__metaclass__. 采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改成大写形式就万事大吉了。 幸运的是，__metaclass__实际上可以被任意调用，它并不需要是一个正式的类（我知道，某些名字里带有'class'的东西并不需要是一个class，画画图理解下，这很有帮助）。 所以，我们这里就先以一个简单的函数作为例子开始。 # 元类会自动将你通常传给'type'的参数作为自己的参数传入 def upper_attr(future_class_name, future_class_parents, future_class_attr): \"\"\" 返回一个将属性列表变为大写字母的类对象 \"\"\" # 选取所有不以'__'开头的属性,并把它们编程大写 uppercase_attr = {} for name, val in future_class_attr.items(): if not name.startswith('__'): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val # 用'type'创建类 return type(future_class_name, future_class_parents, uppercase_attr) __metaclass__ = upper_attr # 将会影响整个模块 class Foo(): # global __metaclass__ won't work with \"object\" though # 我们也可以只在这里定义__metaclass__，这样就只会作用于这个类中 bar = 'bip' print(hasattr(Foo, 'bar')) # 输出: False print(hasattr(Foo, 'BAR')) # 输出: True f = Foo() print(f.BAR) # 输出: 'bip' 现在让我们再做一次，这一次用一个真正的class来当做元类。 # 请记住，'type'实际上是一个类，就像'str'和'int'一样 # 所以，你可以从type继承 class UpperAttrMetaclass(type): # __new__ 是在__init__之前被调用的特殊方法 # __new__是用来创建对象并返回它的方法 # 而__init__只是用来将传入的参数初始化给对象 # 你很少用到__new__，除非你希望能够控制对象的创建 # 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__ # 如果你希望的话，你也可以在__init__中做些事情 # 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用 def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr): uppercase_attr = {} for name, val in future_class_attr.items(): if not name.startswith('__'): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val return type(future_class_name, future_class_parents, uppercase_attr) 但是这不是真正的面向对象(OOP).我们直接调用了type，而且我们没有改写父类的new方法。现在让我们这样去处理: class UpperAttrMetaclass(type): def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr): uppercase_attr = {} for name, val in future_class_attr.items(): if not name.startswith('__'): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val # 重用 type.__new__ 方法 # 这就是基本的OOP编程，没什么魔法 return type.__new__(upperattr_metaclass, future_class_name, future_class_parents, uppercase_attr) 你可能已经注意到了有个额外的参数upperattr_metaclass，这并没有什么特别的。类方法的第一个参数总是表示当前的实例，就像在普通的类方法中的self参数一样。 当然了，为了清晰起见，这里的名字我起的比较长。但是就像self一样，所有的参数都有它们的传统名称。因此，在真实的产品代码中一个元类应该是像这样的： class UpperAttrMetaclass(type): def __new__(cls, clsname, bases, dct): uppercase_attr = {} for name, val in dct.items(): if not name.startswith('__'): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val return type.__new__(cls, clsname, bases, uppercase_attr) 如果使用super方法的话，我们还可以使它变得更清晰一些，这会缓解继承（是的，你可以拥有元类，从元类继承，从type继承） class UpperAttrMetaclass(type): def __new__(cls, clsname, bases, dct): uppercase_attr = {} for name, val in dct.items(): if not name.startswith('__'): uppercase_attr[name.upper()] = val else: uppercase_attr[name] = val return super(UpperAttrMetaclass, cls).__new__(cls, clsname, bases, uppercase_attr) 就是这样，除此之外，关于元类真的没有别的可说的了。 使用到元类的代码比较复杂，这背后的原因倒并不是因为元类本身，而是因为你通常会使用元类去做一些晦涩的事情，依赖于自省，控制继承等等。 确实，用元类来搞些“黑暗魔法”是特别有用的，因而会搞出些复杂的东西来。但就元类本身而言，它们其实是很简单的： 拦截类的创建 修改一个类 返回修改之后的类 为什么要用metaclass类而不是函数? 由于__metaclass__可以接受任何可调用的对象，那为何还要使用类呢，因为很显然使用类会更加复杂啊？ 这里有好几个原因： 意图会更加清晰。当你读到UpperAttrMetaclass(type)时，你知道接下来要发生什么。 你可以使用OOP编程。元类可以从元类中继承而来，改写父类的方法。元类甚至还可以使用元类。 你可以把代码组织的更好。当你使用元类的时候肯定不会是像我上面举的这种简单场景，通常都是针对比较复杂的问题。将多个方法归总到一个类中会很有帮助，也会使得代码更容易阅读。 你可以使用__new__,__init__以及__call__这样的特殊方法。它们能帮你处理不同的任务。就算通常你可以把所有的东西都在__new__里处理掉，有些人还是觉得用__init__更舒服些。 哇哦，这东西的名字是metaclass，肯定非善类，我要小心！ 说了这么多TMD究竟为什么要使用元类？ 现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？ 好吧，一般来说，你根本就用不上它： “元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。” —— Python界的领袖 Tim Peters 元类的主要用途是创建API。一个典型的例子是Django ORM。 它允许你像这样定义： class Person(models.Model): name = models.CharField(max_length=30) age = models.IntegerField() 但是如果你像这样做的话： guy = Person(name='bob', age='35') print(guy.age) 这并不会返回一个IntegerField对象，而是会返回一个int，甚至可以直接从数据库中取出数据。 这是有可能的，因为models.Model定义了__metaclass__， 并且使用了一些魔法能够将你刚刚定义的简单的Person类转变成对数据库的一个复杂hook。 Django框架将这些看起来很复杂的东西通过暴露出一个简单的使用元类的API将其化简，通过这个API重新创建代码，在背后完成真正的工作。 结语 首先，你知道了类其实是能够创建出类实例的对象。 好吧，事实上，类本身也是实例，当然，它们是元类的实例。 >>> class Foo(object): pass >>> id(Foo) 142630324 Python中的一切都是对象，它们要么是类的实例，要么是元类的实例. 除了type.type实际上是它自己的元类，在纯Python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。 其次，元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类： monkey patching 装饰器 当你需要动态修改类时，99%的时间里你最好使用上面这两种技术。当然了，其实在99%的时间里你根本就不需要动态修改类 :D Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 09:23:23 "},"part1/3.html":{"url":"part1/3.html","title":"Python中如何在一个函数中加入多个装饰器?","keywords":"","body":"Python中如何在一个函数中加入多个装饰器? rank ▲ ✰ vote url 3 1346 1485 2648 url Python中如何在一个函数中加入多个装饰器? 怎么做才能让一个函数同时用两个装饰器,像下面这样: @makebold @makeitalic def say(): return \"Hello\" 我希望得到 Hello 我只是想知道装饰器怎么工作的! 去看看文档,答在下面: def makebold(fn): def wrapped(): return \"\" + fn() + \"\" return wrapped def makeitalic(fn): def wrapped(): return \"\" + fn() + \"\" return wrapped @makebold @makeitalic def hello(): return \"hello world\" print hello() ## returns hello world Answer:2 如果你不想看详细的解释的话请看上面那个答案. 装饰器基础 Python的函数都是对象 要了解装饰器,你必须了解Python中的函数都是对象.这个意义非常重要.让我们看看一个简单例子: def shout(word=\"yes\"): return word.capitalize()+\"!\" print shout() # 输出 : 'Yes!' # 作为一个对象,你可以把它赋值给任何变量 scream = shout # 注意啦我们没有加括号,我们并不是调用这个函数,我们只是把函数\"shout\"放在了变量\"scream\"里. # 也就是说我们可以通过\"scream\"调用\"shout\": print scream() # 输出 : 'Yes!' # 你可以删除旧名\"shout\",而且\"scream\"依然指向函数 del shout try: print shout() except NameError, e: print e #输出: \"name 'shout' is not defined\" print scream() # 输出: 'Yes!' 好了,先记住上面的,一会还会用到. Python函数另一个有趣的特性就是你可以在一个函数里定义另一个函数! def talk(): # 你可以在\"talk\"里定义另一个函数 ... def whisper(word=\"yes\"): return word.lower()+\"...\" # 让我们用用它! print whisper() # 每次调用\"talk\"时都会定义一次\"whisper\",然后\"talk\"会调用\"whisper\" talk() # 输出: # \"yes...\" # 但是在\"talk\"意外\"whisper\"是不存在的: try: print whisper() except NameError, e: print e #输出 : \"name 'whisper' is not defined\"* 函数引用 好,终于到了有趣的地方了... 已经知道函数就是对象.因此,对象: 可以赋值给一个变量 可以在其他函数里定义 这就意味着函数可以返回另一个函数.来看看!☺ def getTalk(kind=\"shout\"): # 在函数里定义一个函数 def shout(word=\"yes\"): return word.capitalize()+\"!\" def whisper(word=\"yes\") : return word.lower()+\"...\"; # 返回一个函数 if kind == \"shout\": # 这里不用\"()\",我们不是要调用函数 # 只是返回函数对象 return shout else: return whisper # 怎么用这个特性呢? # 把函数赋值给变量 talk = getTalk() # 可以看到\"talk\"是一个函数对象 print talk # 输出 : # 函数返回的是对象: print talk() # 输出 : Yes! # 不嫌麻烦你也可以这么用 print getTalk(\"whisper\")() # 输出 : yes... 既然可以return一个函数, 你也可以在把函数作为参数传递: def doSomethingBefore(func): print \"I do something before then I call the function you gave me\" print func() doSomethingBefore(scream) # 输出: #I do something before then I call the function you gave me #Yes! 学习装饰器的基本知识都在上面了.装饰器就是\"wrappers\",它可以让你在你装饰函数之前或之后执行程序,而不用修改函数本身. 自己动手实现装饰器 怎么样自己做呢: # 装饰器就是把其他函数作为参数的函数 def my_shiny_new_decorator(a_function_to_decorate): # 在函数里面,装饰器在运行中定义函数: 包装. # 这个函数将被包装在原始函数的外面,所以可以在原始函数之前和之后执行其他代码.. def the_wrapper_around_the_original_function(): # 把要在原始函数被调用前的代码放在这里 print \"Before the function runs\" # 调用原始函数(用括号) a_function_to_decorate() # 把要在原始函数调用后的代码放在这里 print \"After the function runs\" # 在这里\"a_function_to_decorate\" 函数永远不会被执行 # 在这里返回刚才包装过的函数 # 在包装函数里包含要在原始函数前后执行的代码. return the_wrapper_around_the_original_function # 加入你建了个函数,不想修改了 def a_stand_alone_function(): print \"I am a stand alone function, don't you dare modify me\" a_stand_alone_function() #输出: I am a stand alone function, don't you dare modify me # 现在,你可以装饰它来增加它的功能 # 把它传递给装饰器,它就会返回一个被包装过的函数. a_stand_alone_function_decorated = my_shiny_new_decorator(a_stand_alone_function) a_stand_alone_function_decorated() #输出s: #Before the function runs #I am a stand alone function, don't you dare modify me #After the function runs 现在,你或许每次都想用a_stand_alone_function_decorated代替a_stand_alone_function,很简单,只需要用my_shiny_new_decorator返回的函数重写a_stand_alone_function: a_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function) a_stand_alone_function() #输出: #Before the function runs #I am a stand alone function, don't you dare modify me #After the function runs # 想到了吗,这就是装饰器干的事! 让我们看看装饰器的真实面纱 用上一个例子,看看装饰器的语法: @my_shiny_new_decorator def another_stand_alone_function(): print \"Leave me alone\" another_stand_alone_function() #输出: #Before the function runs #Leave me alone #After the function runs 就这么简单.@decorator就是下面的简写: another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function) 装饰器就是 decorator design pattern的pythonic的变种.在Python中有许多经典的设计模式来满足开发者. 当然,你也可以自己写装饰器: def bread(func): def wrapper(): print \"\" func() print \"\" return wrapper def ingredients(func): def wrapper(): print \"#tomatoes#\" func() print \"~salad~\" return wrapper def sandwich(food=\"--ham--\"): print food sandwich() #outputs: --ham-- sandwich = bread(ingredients(sandwich)) sandwich() #outputs: # # #tomatoes# # --ham-- # ~salad~ # 用Python装饰器语法糖: @bread @ingredients def sandwich(food=\"--ham--\"): print food sandwich() #outputs: # # #tomatoes# # --ham-- # ~salad~ # 改变一下顺序: @ingredients @bread def strange_sandwich(food=\"--ham--\"): print food strange_sandwich() #outputs: ##tomatoes# # # --ham-- # # ~salad~ 现在:回答你的问题... 作为结论,相信你现在已经知道答案了: # 字体变粗装饰器 def makebold(fn): # 装饰器将返回新的函数 def wrapper(): # 在之前或者之后插入新的代码 return \"\" + fn() + \"\" return wrapper # 斜体装饰器 def makeitalic(fn): # 装饰器将返回新的函数 def wrapper(): # 在之前或者之后插入新的代码 return \"\" + fn() + \"\" return wrapper @makebold @makeitalic def say(): return \"hello\" print say() #输出: hello # 这相当于 def say(): return \"hello\" say = makebold(makeitalic(say)) print say() #输出: hello 别轻松太早,看看下面的高级用法 装饰器高级用法 在装饰器函数里传入参数 # 这不是什么黑魔法,你只需要让包装器传递参数: def a_decorator_passing_arguments(function_to_decorate): def a_wrapper_accepting_arguments(arg1, arg2): print \"I got args! Look:\", arg1, arg2 function_to_decorate(arg1, arg2) return a_wrapper_accepting_arguments # 当你调用装饰器返回的函数时,也就调用了包装器,把参数传入包装器里, # 它将把参数传递给被装饰的函数里. @a_decorator_passing_arguments def print_full_name(first_name, last_name): print \"My name is\", first_name, last_name print_full_name(\"Peter\", \"Venkman\") # 输出: #I got args! Look: Peter Venkman #My name is Peter Venkman 装饰方法 在Python里方法和函数几乎一样.唯一的区别就是方法的第一个参数是一个当前对象的(self) 也就是说你可以用同样的方式来装饰方法!只要记得把self加进去: def method_friendly_decorator(method_to_decorate): def wrapper(self, lie): lie = lie - 3 # 女性福音 :-) return method_to_decorate(self, lie) return wrapper class Lucy(object): def __init__(self): self.age = 32 @method_friendly_decorator def sayYourAge(self, lie): print \"I am %s, what did you think?\" % (self.age + lie) l = Lucy() l.sayYourAge(-3) #输出: I am 26, what did you think? 如果你想造一个更通用的可以同时满足方法和函数的装饰器,用*args,**kwargs就可以了 def a_decorator_passing_arbitrary_arguments(function_to_decorate): # 包装器接受所有参数 def a_wrapper_accepting_arbitrary_arguments(*args, **kwargs): print \"Do I have args?:\" print args print kwargs # 现在把*args,**kwargs解包 # 如果你不明白什么是解包的话,请查阅: # http://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/ function_to_decorate(*args, **kwargs) return a_wrapper_accepting_arbitrary_arguments @a_decorator_passing_arbitrary_arguments def function_with_no_argument(): print \"Python is cool, no argument here.\" function_with_no_argument() #输出 #Do I have args?: #() #{} #Python is cool, no argument here. @a_decorator_passing_arbitrary_arguments def function_with_arguments(a, b, c): print a, b, c function_with_arguments(1,2,3) #输出 #Do I have args?: #(1, 2, 3) #{} #1 2 3 @a_decorator_passing_arbitrary_arguments def function_with_named_arguments(a, b, c, platypus=\"Why not ?\"): print \"Do %s, %s and %s like platypus? %s\" %\\ (a, b, c, platypus) function_with_named_arguments(\"Bill\", \"Linus\", \"Steve\", platypus=\"Indeed!\") #输出 #Do I have args ? : #('Bill', 'Linus', 'Steve') #{'platypus': 'Indeed!'} #Do Bill, Linus and Steve like platypus? Indeed! class Mary(object): def __init__(self): self.age = 31 @a_decorator_passing_arbitrary_arguments def sayYourAge(self, lie=-3): # 可以加入一个默认值 print \"I am %s, what did you think ?\" % (self.age + lie) m = Mary() m.sayYourAge() #输出 # Do I have args?: #(,) #{} #I am 28, what did you think? 把参数传递给装饰器 好了,如何把参数传递给装饰器自己? 因为装饰器必须接收一个函数当做参数,所以有点麻烦.好吧,你不可以直接把被装饰函数的参数传递给装饰器. 在我们考虑这个问题时,让我们重新回顾下: # 装饰器就是一个'平常不过'的函数 def my_decorator(func): print \"I am an ordinary function\" def wrapper(): print \"I am function returned by the decorator\" func() return wrapper # 因此你可以不用\"@\"也可以调用他 def lazy_function(): print \"zzzzzzzz\" decorated_function = my_decorator(lazy_function) #输出: I am an ordinary function # 之所以输出 \"I am an ordinary function\"是因为你调用了函数, # 并非什么魔法. @my_decorator def lazy_function(): print \"zzzzzzzz\" #输出: I am an ordinary function 看见了吗,和\"my_decorator\"一样只是被调用.所以当你用@my_decorator你只是告诉Python去掉用被变量my_decorator标记的函数. 这非常重要!你的标记能直接指向装饰器. 让我们做点邪恶的事.☺ def decorator_maker(): print \"I make decorators! I am executed only once: \"+\\ \"when you make me create a decorator.\" def my_decorator(func): print \"I am a decorator! I am executed only when you decorate a function.\" def wrapped(): print (\"I am the wrapper around the decorated function. \" \"I am called when you call the decorated function. \" \"As the wrapper, I return the RESULT of the decorated function.\") return func() print \"As the decorator, I return the wrapped function.\" return wrapped print \"As a decorator maker, I return a decorator\" return my_decorator # 让我们建一个装饰器.它只是一个新函数. new_decorator = decorator_maker() #输出: #I make decorators! I am executed only once: when you make me create a decorator. #As a decorator maker, I return a decorator # 下面来装饰一个函数 def decorated_function(): print \"I am the decorated function.\" decorated_function = new_decorator(decorated_function) #输出: #I am a decorator! I am executed only when you decorate a function. #As the decorator, I return the wrapped function # Let’s call the function: decorated_function() #输出: #I am the wrapper around the decorated function. I am called when you call the decorated function. #As the wrapper, I return the RESULT of the decorated function. #I am the decorated function. 一点都不难把. 下面让我们去掉所有可恶的中间变量: def decorated_function(): print \"I am the decorated function.\" decorated_function = decorator_maker()(decorated_function) #输出: #I make decorators! I am executed only once: when you make me create a decorator. #As a decorator maker, I return a decorator #I am a decorator! I am executed only when you decorate a function. #As the decorator, I return the wrapped function. # 最后: decorated_function() #输出: #I am the wrapper around the decorated function. I am called when you call the decorated function. #As the wrapper, I return the RESULT of the decorated function. #I am the decorated function. 让我们简化一下: @decorator_maker() def decorated_function(): print \"I am the decorated function.\" #输出: #I make decorators! I am executed only once: when you make me create a decorator. #As a decorator maker, I return a decorator #I am a decorator! I am executed only when you decorate a function. #As the decorator, I return the wrapped function. #最终: decorated_function() #输出: #I am the wrapper around the decorated function. I am called when you call the decorated function. #As the wrapper, I return the RESULT of the decorated function. #I am the decorated function. 看到了吗?我们用一个函数调用\"@\"语法!:-) 所以让我们回到装饰器的.如果我们在函数运行过程中动态生成装饰器,我们是不是可以把参数传递给函数? def decorator_maker_with_arguments(decorator_arg1, decorator_arg2): print \"I make decorators! And I accept arguments:\", decorator_arg1, decorator_arg2 def my_decorator(func): # 这里传递参数的能力是借鉴了 closures. # 如果对closures感到困惑可以看看下面这个: # http://stackoverflow.com/questions/13857/can-you-explain-closures-as-they-relate-to-python print \"I am the decorator. Somehow you passed me arguments:\", decorator_arg1, decorator_arg2 # 不要忘了装饰器参数和函数参数! def wrapped(function_arg1, function_arg2) : print (\"I am the wrapper around the decorated function.\\n\" \"I can access all the variables\\n\" \"\\t- from the decorator: {0} {1}\\n\" \"\\t- from the function call: {2} {3}\\n\" \"Then I can pass them to the decorated function\" .format(decorator_arg1, decorator_arg2, function_arg1, function_arg2)) return func(function_arg1, function_arg2) return wrapped return my_decorator @decorator_maker_with_arguments(\"Leonard\", \"Sheldon\") def decorated_function_with_arguments(function_arg1, function_arg2): print (\"I am the decorated function and only knows about my arguments: {0}\" \" {1}\".format(function_arg1, function_arg2)) decorated_function_with_arguments(\"Rajesh\", \"Howard\") #输出: #I make decorators! And I accept arguments: Leonard Sheldon #I am the decorator. Somehow you passed me arguments: Leonard Sheldon #I am the wrapper around the decorated function. #I can access all the variables # - from the decorator: Leonard Sheldon # - from the function call: Rajesh Howard #Then I can pass them to the decorated function #I am the decorated function and only knows about my arguments: Rajesh Howard 好了,上面就是带参数的装饰器.参数可以设置成变量: c1 = \"Penny\" c2 = \"Leslie\" @decorator_maker_with_arguments(\"Leonard\", c1) def decorated_function_with_arguments(function_arg1, function_arg2): print (\"I am the decorated function and only knows about my arguments:\" \" {0} {1}\".format(function_arg1, function_arg2)) decorated_function_with_arguments(c2, \"Howard\") #输出: #I make decorators! And I accept arguments: Leonard Penny #I am the decorator. Somehow you passed me arguments: Leonard Penny #I am the wrapper around the decorated function. #I can access all the variables # - from the decorator: Leonard Penny # - from the function call: Leslie Howard #Then I can pass them to the decorated function #I am the decorated function and only knows about my arguments: Leslie Howard 你可以用这个小技巧把任何函数的参数传递给装饰器.如果你愿意还可以用*args,**kwargs.但是一定要记住了装饰器只能被调用一次.当Python载入脚本后,你不可以动态的设置参数了.当你运行import x,函数已经被装饰,所以你什么都不能动了. 来练习一下:装饰装饰器 好吧,作为奖励,我就给你讲讲如何怎么让所有的装饰器接收任何参数.为了接收参数,我们用另外的函数来建我们的装饰器. 我们包装装饰器. 还有什么我们可以看到吗? 对了,装饰器! 让我们来为装饰器一个装饰器: def decorator_with_args(decorator_to_enhance): \"\"\" 这个函数将被用来作为装饰器. 它必须去装饰要成为装饰器的函数. 休息一下. 它将允许所有的装饰器可以接收任意数量的参数,所以以后你不必为每次都要做这个头疼了. saving you the headache to remember how to do that every time. \"\"\" # 我们用传递参数的同样技巧. def decorator_maker(*args, **kwargs): # 我们动态的建立一个只接收一个函数的装饰器, # 但是他能接收来自maker的参数 def decorator_wrapper(func): # 最后我们返回原始的装饰器,毕竟它只是'平常'的函数 # 唯一的陷阱:装饰器必须有这个特殊的,否则将不会奏效. return decorator_to_enhance(func, *args, **kwargs) return decorator_wrapper 下面是如何用它们: # 下面的函数是你建来当装饰器用的,然后把装饰器加到上面:-) # 不要忘了这个 \"decorator(func, *args, **kwargs)\" @decorator_with_args def decorated_decorator(func, *args, **kwargs): def wrapper(function_arg1, function_arg2): print \"Decorated with\", args, kwargs return func(function_arg1, function_arg2) return wrapper # 现在你用你自己的装饰装饰器来装饰你的函数(汗~~~) @decorated_decorator(42, 404, 1024) def decorated_function(function_arg1, function_arg2): print \"Hello\", function_arg1, function_arg2 decorated_function(\"Universe and\", \"everything\") #输出: #Decorated with (42, 404, 1024) {} #Hello Universe and everything # Whoooot! 估计你看到这和你刚看完爱因斯坦相对论差不多,但是现在如果明白怎么用就好多了吧. 最好的练习:装饰器 装饰器是Python2.4里引进的,所以确保你的Python解析器的版本>=2.4 装饰器使函数调用变慢了.一定要记住. 装饰器不能被取消(有些人把装饰器做成可以移除的但是没有人会用)所以一旦一个函数被装饰了.所有的代码都会被装饰. 用装饰器装饰函数将会很难debug(在>=2.5版本将会有所改善;看下面) functools模块在2.5被引进.它包含了一个functools.wraps()函数,可以复制装饰器函数的名字,模块和文档给它的包装器. (事实上:functools.wraps()是一个装饰器!☺) #为了debug,堆栈跟踪将会返回函数的 __name__ def foo(): print \"foo\" print foo.__name__ #输出: foo # 如果加上装饰器,将变得有点复杂 def bar(func): def wrapper(): print \"bar\" return func() return wrapper @bar def foo(): print \"foo\" print foo.__name__ #输出: wrapper # \"functools\" 将有所帮助 import functools def bar(func): # 我们所说的\"wrapper\",正在包装 \"func\", # 好戏开始了 @functools.wraps(func) def wrapper(): print \"bar\" return func() return wrapper @bar def foo(): print \"foo\" print foo.__name__ #输出: foo 怎么使用装饰器? 现在遇到了大问题:我们用装饰器干什么? 看起来很黄很暴力,但是如果有实际用途就更好了.好了这里有1000个用途.传统的用法就是用它来为外部的库的函数(你不能修改的)做扩展,或者debug(你不想修改它,因为它是暂时的). 你也可以用DRY的方法去扩展一些函数,像: def benchmark(func): \"\"\" A decorator that prints the time a function takes to execute. \"\"\" import time def wrapper(*args, **kwargs): t = time.clock() res = func(*args, **kwargs) print func.__name__, time.clock()-t return res return wrapper def logging(func): \"\"\" A decorator that logs the activity of the script. (it actually just prints it, but it could be logging!) \"\"\" def wrapper(*args, **kwargs): res = func(*args, **kwargs) print func.__name__, args, kwargs return res return wrapper def counter(func): \"\"\" A decorator that counts and prints the number of times a function has been executed \"\"\" def wrapper(*args, **kwargs): wrapper.count = wrapper.count + 1 res = func(*args, **kwargs) print \"{0} has been used: {1}x\".format(func.__name__, wrapper.count) return res wrapper.count = 0 return wrapper @counter @benchmark @logging def reverse_string(string): return str(reversed(string)) print reverse_string(\"Able was I ere I saw Elba\") print reverse_string(\"A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!\") #输出: #reverse_string ('Able was I ere I saw Elba',) {} #wrapper 0.0 #wrapper has been used: 1x #ablE was I ere I saw elbA #reverse_string ('A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!',) {} #wrapper 0.0 #wrapper has been used: 2x #!amanaP :lanac a ,noep a ,stah eros ,raj a ,hsac ,oloR a ,tur a ,mapS ,snip ,eperc a ,)lemac a ro( niaga gab ananab a ,gat a ,nat a ,gab ananab a ,gag a ,inoracam ,elacrep ,epins ,spam ,arutaroloc a ,shajar ,soreh ,atsap ,eonac a ,nalp a ,nam A 当然,装饰器的好处就是你可以用它们来做任何事而不用重写,DRY: @counter @benchmark @logging def get_random_futurama_quote(): from urllib import urlopen result = urlopen(\"http://subfusion.net/cgi-bin/quote.pl?quote=futurama\").read() try: value = result.split(\"\")[1].split(\"\")[0] return value.strip() except: return \"No, I'm ... doesn't!\" print get_random_futurama_quote() print get_random_futurama_quote() #输出: #get_random_futurama_quote () {} #wrapper 0.02 #wrapper has been used: 1x #The laws of science be a harsh mistress. #get_random_futurama_quote () {} #wrapper 0.01 #wrapper has been used: 2x #Curse you, merciful Poseidon! Python自身提供了几个装饰器,像property, staticmethod. Django用装饰器管理缓存和试图的权限. Twisted用来修改异步函数的调用. 好大的坑! Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 09:06:14 "},"part1/4.html":{"url":"part1/4.html","title":"用Python如何检测一个文件是否存在?","keywords":"","body":"用Python如何检测一个文件是否存在? rank ▲ ✰ vote url 4 1266 285 929 url 用Python如何一个文件是否存在? 不用try:语句可以一个文件存在 如果不确定文件存不存在,可以这样做: import os.path os.path.isfile(fname) Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 09:06:52 "},"part1/5.html":{"url":"part1/5.html","title":"在Python中有三元运算符吗?","keywords":"","body":"在Python中有三元运算符吗? rank ▲ ✰ vote url 5 1187 203 1370 url 在Python中有三元运算符吗? 如果没有,可以像其他语言用的简单方法来实现吗? 有,在2.5版本中加入.对于python初学者可能有点难以理解,所以要记住了. 语法如下: a if test else b 根据test的布尔值来判断返回的是a还是b;如果test为真则返回a,反之则返回b. 来个大栗子: >>> 'true' if True else 'false' 'true' >>> 'true' if False else 'false' 'false' 官方文档: Conditional expressions Is there an equivalent of C’s ”?:” ternary operator? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 09:07:19 "},"part1/6.html":{"url":"part1/6.html","title":"在Python中调用外部命令?","keywords":"","body":"在Python中调用外部命令? rank ▲ ✰ vote url 6 1161 520 1167 url 在Python中调用外部命令? 怎么在Python脚本里调用外部命令?(就好像直接输入在Unix shell中或者windows的命令行里) 来来来,我给你叨咕叨咕各种方法和各自优缺点: os.system(\"命令加参数\")把命令和参数传递给你系统的shell中.用这个命令的好处在于你可以一次运行好多命令还可以设置管道来进行重定向.来个栗子:os.system(\"命令 输出文件\")尽管它非常方便,但是你还是不得不手动输入像空格这样的sehll字符.从另一方面讲,对于运行简单的shell命令而不去调用外部程序来说的话还是非常好用的. stream = os.popen(\"命令和参数\")这个命令和os.system差不多,但是它提供了一个连接标准输入/输出的管道.还有其他3个popen可以调用.如果你传递一个字符串,你的命令会把它传递给shell,如果你传递的是一个列表,那么就不用担心溢出字符了(escaping characters). subprocess模块的管道Popen.这个Popen是打算用来替代os.popen的方法,它有点复杂: print subprocess.Popen(\"echo Hello World\", shell=True,stdout=PIPE).stdout.read() 而用os.popen: print os.popen(\"echo Hello World\").read() 它最大的优点就是一个类里代替了原来的4个不同的popen subprocess的call方法.它的基本用法和上面的Popen类参数一致,但是它会等待命令结束后才会返回程序.来个大狸子: return_code = subprocess.call(\"echo Hello World\", shell=True) os模块里也有C语言里fork/exec/spawn方法,但是我不建议你直接用它们. subprocess模块可能更适合你. 最后请注意在你传递到shell的命令一定要注意参数的安全性,给你个提示,看下面代码 print subprocess.Popen(\"echo %s \" % user_input, stdout=PIPE).stdout.read() 想象一下如果哪个 SB 输入 my mama didnt love me && rm -rf / Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 09:08:01 "},"part1/7.html":{"url":"part1/7.html","title":"在Python里如何用枚举类型?","keywords":"","body":"在Python里如何用枚举类型? rank ▲ ✰ vote url 7 1112 431 1201 url 在Python里如何用枚举类型? 我是一个C#开发者,但是我现在做的工作是关于Python的. 怎么在Python里代替枚举类型呢? PEP435标准里已经把枚举添加到Python3.4版本,在Pypi中也可以向后支持3.3, 3.2, 3.1, 2.7, 2.6, 2.5, 和 2.4版本. 如果想向后兼容$ pip install enum34,如果下载enum(没有数字)将会是另一个版本. from enum import Enum Animal = Enum('Animal', 'ant bee cat dog') 或者等价于: class Animals(Enum): ant = 1 bee = 2 cat = 3 dog = 4 在更早的版本,下面这种方法来完成枚举: def enum(**enums): return type('Enum', (), enums) 像这样来用: >>> Numbers = enum(ONE=1, TWO=2, THREE='three') >>> Numbers.ONE 1 >>> Numbers.TWO 2 >>> Numbers.THREE 'three' 也很容易支持自动计数,像下面这样: def enum(*sequential, **named): enums = dict(zip(sequential, range(len(sequential))), **named) return type('Enum', (), enums) 这样用: >>> Numbers = enum('ZERO', 'ONE', 'TWO') >>> Numbers.ZERO 0 >>> Numbers.ONE 1 如果要把值转换为名字可以加入下面的方法: def enum(*sequential, **named): enums = dict(zip(sequential, range(len(sequential))), **named) reverse = dict((value, key) for key, value in enums.iteritems()) enums['reverse_mapping'] = reverse return type('Enum', (), enums) 这样会覆盖名字下的所有东西,但是对于枚举的输出很有用.如果转换的值不存在就会抛出KeyError异常.用前面的例子: >>> Numbers.reverse_mapping['three'] 'THREE' Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 09:08:30 "},"part1/8.html":{"url":"part1/8.html","title":"怎么在windows下安装pip?","keywords":"","body":"怎么在windows下安装pip? rank ▲ ✰ vote url 8 919 442 608 url 怎么在windows下安装pip? 怎么在windows下安装pip? Python3.4+ 好消息,Python3.4已经自带Pip.这是所有Python发行版中最好的特性了.方便了所有人使用公共库.新手再也不用操心安装额外库的繁琐步骤了.它自带的包管理器中加入了 Ruby, Nodejs, Haskell, Perl, Go等其他几乎所有的开源社区流行语言.谢谢Python. 当然,这并不意味着所有的Python包问题已经解决.在一段时间看来仍然不乐观.我在Python有包管理系统吗?也讨论过这个问题. 同样对于Python2.x用户(几乎一般人),还没有计划在Python中自带Pip. 只能自己动手了. Python 2.x 和 Python ≤ 3.3 尽管Python吹的简单易用的哲学,但是Python不提供包管理工具.更糟糕的是,Pip直到现在还是非常的难以安装. 官方指南 在 http://www.pip-installer.org/en/latest/installing.html 下载get-pip.py,把它保存下来注意不要把.py后缀改成.txt. 然后在命令提示符上输入: python get-pip.py 你可能还需要管理员权限来执行它.跟着做 http://technet.microsoft.com/en-us/library/cc947813(v=ws.10).aspx 另一种方法 官方文档告诉我们安装Pip和各种依赖的源.对有经验的人来说太麻烦了,对于新手又有点难. Christoph Gohlke已经为我们做好了下载Python包的安装器(.msi).它可以为的Python版本建立依赖,不管32bit还是64bit.你只需要: 安装setuptools http://www.lfd.uci.edu/~gohlke/pythonlibs/#setuptools 安装pip http://www.lfd.uci.edu/~gohlke/pythonlibs/#pip 在我这,Pip安装到了C:\\Python27\\Scripts\\pip.exe.在你的电脑上找到pip.exe,然后把文件夹(eg.C:\\Python27\\Scripts)添加你的路径(编辑你的环境变量).现在你应当可以在命令行中运行pip了.试试安装一个包: pip install httpie 终于可以运行了!下面是一些问题的解决办法 代理问题 如果你在办公环境,那么你有可能有一个HTTP代理.把环境变量设置成http_proxy和https_proxy.大多数应用程序都管用(包括免费软件).语法如下: http://proxy_url:port http://username:password@proxy_url:port 如果你不幸用的是微软的NTLM代理.那就没救了.唯一的办法就是安装一个友好的代理吧. http://cntlm.sourceforge.net/ 找不到vcvarsall.bat Python有的模块是用C或C++写的.Pip尝试从源码编译.如果你没有安装或设置过C/C++编译器,你将会看到下面的错误: Error: Unable to find vcvarsall.bat 你可以通过像MinGw或者Visual C++这样的C++编译器来解决此问题.微软实际上已经自带了一个为Python准备的编译器,或者试试 http://aka.ms/vcpython27 可以这个Christoph的网站来查看安装包 http://www.lfd.uci.edu/~gohlke/pythonlibs/ Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 09:09:17 "},"part1/9.html":{"url":"part1/9.html","title":"如何在一个表达式里合并两个字典?","keywords":"","body":"如何在一个表达式里合并两个字典? rank ▲ ✰ vote url 9 909 224 1035 url 如何在一个表达式里合并两个字典? 我有两个Python字典,我想写一个表达式来返回两个字典的合并.update()方法返回的是空值而不是返回合并后的对象. >>> x = {'a':1, 'b': 2} >>> y = {'b':10, 'c': 11} >>> z = x.update(y) >>> print z None >>> x {'a': 1, 'b': 10, 'c': 11} 怎么样才能最终让值保存在z而不是x? 可以用下面的方法: z = dict(x.items() + y.items()) 最后就是你想要的最终结果保存在字典z中,而键b的值会被第二个字典的值覆盖. >>> x = {'a':1, 'b': 2} >>> y = {'b':10, 'c': 11} >>> z = dict(x.items() + y.items()) >>> z {'a': 1, 'c': 11, 'b': 10} 如果你用的是Python3的话稍微有点麻烦: >>> z = dict(list(x.items()) + list(y.items())) >>> z {'a': 1, 'c': 11, 'b': 10} 还可以这样: z = x.copy() z.update(y) Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 09:10:47 "},"part1/10.html":{"url":"part1/10.html","title":"有方法让Python运行在Android上吗?","keywords":"","body":"有方法让Python运行在Android上吗? rank ▲ ✰ vote url 10 903 326 325 url 有方法让Python运行在Android上吗? 我喜欢Android平台.试试上我和几个朋友在Spoxt项目里在用ADC(数模转换器?) 但是我一点也不喜欢Java.我们工作在S60版本而且一个不错的Python的API.我知道Android上没有官方的Python版本,但是既然有Jython,有没有什么方法让它们能在Android上工作? 有一种方法,使用Kivy: 交互界面快速开发应用的Python开源库,像多点触控app. Kivy运行在 Linux, Windows, OS X, Android and iOS.你也可以在所有的平台上运行Python代码 Kivy的应用 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 09:11:30 "},"part1/11.html":{"url":"part1/11.html","title":"用字典的值(value)对字典进行排序","keywords":"","body":"用字典的值(value)对字典进行排序 rank ▲ ✰ vote url 11 867 379 1107 url 用字典的值(key)对字典进行排序 我有个字典,字典的值来自于数据库:一个是字符串,一个是数字.字符串是唯一的,所以键(key)就是字符串. 我可以用键(key)来排序,但是怎么用值(value)来排序呢? 注:我已经看过另一个问题怎样对列表中的字典的键值(key)对字典进行排序?,或许这种方法可以,但是我确实只需要一个字典,我想看看还有其他更好的方法. 对字典进行排序是不可能的,只有把字典转换成另一种方式才能排序.字典本身是无序的,但是像列表元组等其他类型是有序的.所以你需要用一个元组列表来表示排序的字典. 例子: import operator x = {1: 2, 3: 4, 4:3, 2:1, 0:0} sorted_x = sorted(x.items(), key=operator.itemgetter(1)) sorted_x是一个元组列表,用每个元组的第二个元素进行排序.dict(sorted_x) == x. 如果想要用键(key)来进行排序: import operator x = {1: 2, 3: 4, 4:3, 2:1, 0:0} sorted_x = sorted(x.items(), key=operator.itemgetter(0)) 你也可以: sorted(d.items(), key=lambda x: x[1]) Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 09:33:46 "},"part1/12.html":{"url":"part1/12.html","title":"如何在一个函数里使用全局变量?","keywords":"","body":"如何在一个函数里用全局变量? rank ▲ ✰ vote url 12 851 228 1287 url 如何在一个函数里用全局变量? 如果我在一个函数里建了一个全局变量,那么我怎么在另一个函数里使用这个全局变量? 我需要把这个全局变量赋值给这个函数的局部变量吗? 如果你要在别的函数里使用全局变量,只要在被调用全局变量函数的里事先用global声明一下: globvar = 0 def set_globvar_to_one(): global globvar # 需要用global修饰一下globvar globvar = 1 def print_globvar(): print globvar # 如果要读globbar的值的话不需要用global修饰 set_globvar_to_one() print_globvar() # 输出 1 我猜正是因为全局变量比较危险,所以Python为了确保你真的知道它是全局变量,所以需要加一个global关键字. Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 09:34:02 "},"part1/13.html":{"url":"part1/13.html","title":"Python中的\"小震撼\":变化的默认参数","keywords":"","body":"Python中的\"小震撼\":变化的默认参数 rank ▲ ✰ vote url 13 811 323 639 url Python中的\"小震撼\":变化的默认参数 许多 Python 老手也被下面的问题困扰: def foo(a=[]): a.append(5) return a Python 新手估计可能会想这个函数返回一个只有元素[5]的列表.但是结果却出人意料: >>> foo() [5] >>> foo() [5, 5] >>> foo() [5, 5, 5] >>> foo() [5, 5, 5, 5] >>> foo() 我的一个经理曾经碰到过这个特性并把它叫做语言的\"动态设计缺陷\". 这个现象应当有更深层次的解释, 如果你不懂它的内部它确实非常令人困惑. 然而我不能回答下面的问题:是什么原因使默认参数在函数的定义时被绑定,而不是在执行时?我怀疑这个特性在现实中有没有实际的用途(就像在C语言中有谁去用静态变量?) 事实上这并不是设计缺陷,也不是什么内部或性能原因. 原因很简单,Python中的函数是最高等级的对象,而不仅仅是一小段代码. 试着这么来理解:一个函数是一个被它自己定义而执行的对象;默认参数是一种\"成员数据\",所以它们的状态和其他对象一样,会随着每一次调用而改变. Effbot在它的Python中的默认参数对这种行为的原因解释的非常清楚!我强烈建议你读一读能对函数对象的工作原理有更深一步的了解. Python 中的默认参数(文章翻译) Python 默认参数很容易让新手犯错. 引起错误的原因通常是使用可变(mutable)对象作为了参数的默认值, 这个可变对象是可以被修改的, 比如说列表(list)和字典(dict) 例如: >>> def function(data=[]): ... data.append(1) ... return data ... >>> function() [1] >>> function() [1, 1] >>> function() [1, 1, 1] 可以看到上面的列表(list)越来越长, 如果检查这个列表的id, 会发现他返回的是同一个值: >>> id(function()) 12516768 >>> id(function()) 12516768 >>> id(function()) 12516768 原因很简单: 在每次函数调用的时候都使用同一个对象(object), 这个可修改的特性我们叫做 \"sticky\". 原理 只有当\"def\"语句执行的时候才会对默认参数值进行赋值, 可以看看文档的定义: https://docs.python.org/2.0/ref/function.html 还要注意的是在Python 中 \"def\" 是可执行语句, 默认参数仅在\"def\" 语句环境里生效.每次执行\"def\"语句都会创建一个新的函数对象(每次都会对默认参数进行赋值) Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-09 20:02:45 "},"part1/13-extend.html":{"url":"part1/13-extend.html","title":"拓展:Python中的默认参数","keywords":"","body":"拓展:Python中的默认参数 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 09:43:50 "},"part1/14.html":{"url":"part1/14.html","title":"装饰器@staticmethod和@classmethod有什么区别?","keywords":"","body":"装饰器@staticmethod和@classmethod有什么区别? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/15.html":{"url":"part1/15.html","title":"检查列表是否为空的最好方法","keywords":"","body":"检查列表是否为空的最好方法 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/16.html":{"url":"part1/16.html","title":"怎么用引用来改变一个变量?","keywords":"","body":"怎么用引用来改变一个变量? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/17.html":{"url":"part1/17.html","title":"检查一个文件夹是否存在,如果不存在就创建它","keywords":"","body":"检查一个文件夹是否存在,如果不存在就创建它 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/18.html":{"url":"part1/18.html","title":"if name == \"main\":是干嘛的?","keywords":"","body":"if name == \"main\":是干嘛的? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/19.html":{"url":"part1/19.html","title":"理解Python中super()和init()方法","keywords":"","body":"理解Python中super()和init()方法 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/20.html":{"url":"part1/20.html","title":"20","keywords":"","body":"20 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/21.html":{"url":"part1/21.html","title":"在循环中获取索引(数组下标)","keywords":"","body":"在循环中获取索引(数组下标) Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/22.html":{"url":"part1/22.html","title":"Python中的appen和extend","keywords":"","body":"Python中的appen和extend Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/23.html":{"url":"part1/23.html","title":"字典里添加元素的方法","keywords":"","body":"字典里添加元素的方法 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/24.html":{"url":"part1/24.html","title":"Python中有检查字符串包含的方法吗?","keywords":"","body":"Python中有检查字符串包含的方法吗? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/25.html":{"url":"part1/25.html","title":"在一行里获取多个异常","keywords":"","body":"在一行里获取多个异常 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/26.html":{"url":"part1/26.html","title":"类里的静态变量","keywords":"","body":"类里的静态变量 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/27.html":{"url":"part1/27.html","title":"如何移除换行符?","keywords":"","body":"如何移除换行符? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/28.html":{"url":"part1/28.html","title":"为什么在C++中读取stdin中的行会比Python慢呢?","keywords":"","body":"为什么在C++中读取stdin中的行会比Python慢呢? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/29.html":{"url":"part1/29.html","title":"理解Python切片","keywords":"","body":"理解Python切片 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/30.html":{"url":"part1/30.html","title":"怎么在终端里输出颜色?","keywords":"","body":"怎么在终端里输出颜色? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/31.html":{"url":"part1/31.html","title":"静态方法","keywords":"","body":"静态方法 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/32.html":{"url":"part1/32.html","title":"为什么用pip比用easy_install的好?","keywords":"","body":"为什么用pip比用easy_install的好? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/33.html":{"url":"part1/33.html","title":"把字符串解析成浮点数或者整数","keywords":"","body":"把字符串解析成浮点数或者整数 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/34.html":{"url":"part1/34.html","title":"怎么样获取一个列表的长度?","keywords":"","body":"怎么样获取一个列表的长度? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/35.html":{"url":"part1/35.html","title":"35","keywords":"","body":"35 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/36.html":{"url":"part1/36.html","title":"在Python里怎么读取stdin?","keywords":"","body":"在Python里怎么读取stdin? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/37.html":{"url":"part1/37.html","title":"为什么是string.join(list)而不是list.join(string)?","keywords":"","body":"为什么是string.join(list)而不是list.join(string)? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/38.html":{"url":"part1/38.html","title":"在Python里获取当前时间","keywords":"","body":"在Python里获取当前时间 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/39.html":{"url":"part1/39.html","title":"在Python中列出目录中的所有文件","keywords":"","body":"在Python中列出目录中的所有文件 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/40.html":{"url":"part1/40.html","title":"在Python怎么样才能把列表分割成同样大小的块?","keywords":"","body":"在Python怎么样才能把列表分割成同样大小的块? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/41.html":{"url":"part1/41.html","title":"检查一个字符串是否是一个数字","keywords":"","body":"检查一个字符串是否是一个数字 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/42.html":{"url":"part1/42.html","title":"查找列表中某个元素的下标","keywords":"","body":"查找列表中某个元素的下标 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/43.html":{"url":"part1/43.html","title":"获得一个字符串的子串","keywords":"","body":"获得一个字符串的子串 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/44.html":{"url":"part1/44.html","title":"为什么代码在一个函数里运行的更快?","keywords":"","body":"为什么代码在一个函数里运行的更快? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/45.html":{"url":"part1/45.html","title":"合并列表中的列表","keywords":"","body":"合并列表中的列表 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/46.html":{"url":"part1/46.html","title":"Python使用什么IDE?","keywords":"","body":"Python使用什么IDE? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/47.html":{"url":"part1/47.html","title":"检查一个键在字典中是否存在","keywords":"","body":"检查一个键在字典中是否存在 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/48.html":{"url":"part1/48.html","title":"在列表中随机取一个元素","keywords":"","body":"在列表中随机取一个元素 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/49.html":{"url":"part1/49.html","title":"通过列表中字典的值对列表进行排序","keywords":"","body":"通过列表中字典的值对列表进行排序 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/50.html":{"url":"part1/50.html","title":"复制文件","keywords":"","body":"复制文件 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/51.html":{"url":"part1/51.html","title":"error: Unable to find vcvarsall.bat","keywords":"","body":"error: Unable to find vcvarsall.bat Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/52.html":{"url":"part1/52.html","title":"如何移除用easy_install下载的包?","keywords":"","body":"如何移除用easy_install下载的包? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/53.html":{"url":"part1/53.html","title":"从相对路径引入一个模块","keywords":"","body":"从相对路径引入一个模块 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/54.html":{"url":"part1/54.html","title":"如何知道一个对象有一个特定的属性?","keywords":"","body":"如何知道一个对象有一个特定的属性? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/55.html":{"url":"part1/55.html","title":"args 和 *kwargs","keywords":"","body":"args 和 *kwargs Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/56.html":{"url":"part1/56.html","title":"如何获取实例的类名","keywords":"","body":"如何获取实例的类名 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/57.html":{"url":"part1/57.html","title":"字典推导式","keywords":"","body":"字典推导式 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/58.html":{"url":"part1/58.html","title":"反转字符","keywords":"","body":"反转字符 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/59.html":{"url":"part1/59.html","title":"通过函数名的字符串来调用这个函数","keywords":"","body":"通过函数名的字符串来调用这个函数 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/60.html":{"url":"part1/60.html","title":"如何测量脚本运行时间?","keywords":"","body":"如何测量脚本运行时间? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/61.html":{"url":"part1/61.html","title":"获取列表最后一个元素","keywords":"","body":"获取列表最后一个元素 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/62.html":{"url":"part1/62.html","title":"Python中用什么代替switch语句?","keywords":"","body":"Python中用什么代替switch语句? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/63.html":{"url":"part1/63.html","title":"生成包含大写字母和数字的随机字符串","keywords":"","body":"生成包含大写字母和数字的随机字符串 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/64.html":{"url":"part1/64.html","title":"在实例名字前单下划线和双下划线的含义","keywords":"","body":"在实例名字前单下划线和双下划线的含义 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/65.html":{"url":"part1/65.html","title":"合并两个列表","keywords":"","body":"合并两个列表 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/66.html":{"url":"part1/66.html","title":"输出到stderr","keywords":"","body":"输出到stderr Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/67.html":{"url":"part1/67.html","title":"把字符串转化成时间","keywords":"","body":"把字符串转化成时间 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/68.html":{"url":"part1/68.html","title":"查看一个对象的类型","keywords":"","body":"查看一个对象的类型 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/69.html":{"url":"part1/69.html","title":"手动抛出异常","keywords":"","body":"手动抛出异常 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/70.html":{"url":"part1/70.html","title":"字符串格式化:%和.format","keywords":"","body":"字符串格式化:%和.format Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/71.html":{"url":"part1/71.html","title":"71","keywords":"","body":"71 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/72.html":{"url":"part1/72.html","title":"怎么样去除空格(包括tab)?","keywords":"","body":"怎么样去除空格(包括tab)? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/73.html":{"url":"part1/73.html","title":"把文件一行行读入数组","keywords":"","body":"把文件一行行读入数组 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/74.html":{"url":"part1/74.html","title":"74","keywords":"","body":"74 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/75.html":{"url":"part1/75.html","title":"在Python中如何直达搜一个对象是可迭代的?","keywords":"","body":"在Python中如何直达搜一个对象是可迭代的? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/76.html":{"url":"part1/76.html","title":"用pip升级所有包","keywords":"","body":"用pip升级所有包 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/77.html":{"url":"part1/77.html","title":"给字符串填充0","keywords":"","body":"给字符串填充0 Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/78.html":{"url":"part1/78.html","title":"如何离开/退出/停用Python的virtualenv？","keywords":"","body":"如何离开/退出/停用Python的virtualenv？ Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/79.html":{"url":"part1/79.html","title":"Python中*和参数有什么用?","keywords":"","body":"Python中*和参数有什么用? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "},"part1/80.html":{"url":"part1/80.html","title":"如何连接MySQL?","keywords":"","body":"如何连接MySQL? Copyright © taizilongxu 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-04-08 08:48:18 "}}